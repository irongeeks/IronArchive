# Story 1.3: Backend API Foundation with Fiber Framework

## Status

**Approved**

## Story

**As a** developer,
**I want** the backend API server scaffolded with routing, middleware, and error handling,
**so that** I can build endpoints efficiently with consistent patterns.

## Acceptance Criteria

1. Fiber v3 application initialized with structured routing
2. Environment configuration loaded from `.env` file (database URL, Redis URL, JWT secret, server port)
3. Middleware configured: CORS, request logging, panic recovery, request ID generation
4. Database connection pool established using pgx with health check endpoint (`GET /health`)
5. Redis client initialized with connection validation
6. Meilisearch client initialized with connection validation
7. Structured logging configured (JSON format to stdout) with log levels (DEBUG, INFO, WARN, ERROR)
8. Error handling middleware returns consistent JSON error responses with status codes
9. API versioning structure (`/api/v1/...`) established
10. Server starts successfully and responds to health check with status 200 and service connectivity status
11. Unit tests for health check endpoint pass
12. Server gracefully shuts down on SIGTERM/SIGINT, closing database connections

## Tasks / Subtasks

- [ ] **Task 1: Create Go application entrypoint and project structure** (AC: 1)
  - [ ] Create `/backend/cmd/server/main.go` as application entrypoint
  - [ ] Initialize Go module dependencies: Fiber v3, pgx/v5, Redis client, Meilisearch SDK, Zap logger
  - [ ] Create `/backend/internal/config/config.go` for configuration management
  - [ ] Create `/backend/internal/utils/logger.go` for structured logging setup

- [ ] **Task 2: Implement configuration loading from environment** (AC: 2, 7)
  - [ ] Create Config struct with fields: DatabaseURL, RedisURL, MeilisearchURL, JWTSecret, ServerPort, LogLevel
  - [ ] Implement `LoadConfig()` function that reads from environment variables
  - [ ] Load `.env` file using godotenv package
  - [ ] Validate required config fields are present, return error if missing
  - [ ] Initialize Zap structured logger with JSON encoder and configured log level

- [ ] **Task 3: Initialize database connection pool** (AC: 4)
  - [ ] Create `/backend/internal/database/postgres.go`
  - [ ] Implement `NewPostgresPool(ctx context.Context, databaseURL string)` function
  - [ ] Configure pgxpool with connection limits (min: 2, max: 10)
  - [ ] Implement connection health check: `db.Ping(ctx)`
  - [ ] Return pgxpool.Pool instance for dependency injection

- [ ] **Task 4: Initialize Redis and Meilisearch clients** (AC: 5, 6)
  - [ ] Create `/backend/internal/cache/redis.go`
  - [ ] Implement `NewRedisClient(redisURL string)` with connection validation
  - [ ] Create `/backend/internal/search/meilisearch.go`
  - [ ] Implement `NewMeilisearchClient(meilisearchURL string, apiKey string)` with connection validation
  - [ ] Both clients should validate connectivity on initialization

- [ ] **Task 5: Create Fiber application with middleware** (AC: 1, 3, 7, 8)
  - [ ] **Create custom middleware files:**
    - [ ] Create `/backend/internal/api/middleware/cors.go` - configure CORS with allowed origins
    - [ ] Create `/backend/internal/api/middleware/logging.go` - log request method, path, status, duration
    - [ ] Create `/backend/internal/api/middleware/error_handler.go` - return consistent JSON error format
  - [ ] **Initialize and configure Fiber app in `main.go`:**
    - [ ] Initialize Fiber v3 app with ErrorHandler config
    - [ ] Apply middleware in correct order: RequestID → Logging → CORS → Recover
    - [ ] Import required middleware packages: `requestid`, `recover` from `fiber/v3/middleware`

- [ ] **Task 6: Implement health check endpoint** (AC: 4, 10)
  - [ ] Create `/backend/internal/api/handlers/health.go`
  - [ ] Implement `HealthHandler` with dependency on db, Redis, Meilisearch clients
  - [ ] Endpoint `GET /health` checks connectivity to all services
  - [ ] Return JSON response with structure: `{"status": "healthy", "services": {"database": "ok", "redis": "ok", "meilisearch": "ok"}}`
  - [ ] Return 200 if all services healthy, 503 if any service unhealthy
  - [ ] Log health check results at DEBUG level

- [ ] **Task 7: Setup API versioning and route registration** (AC: 9)
  - [ ] Create `/backend/internal/api/routes.go`
  - [ ] Implement `SetupRoutes(app *fiber.App, handlers...)` function
  - [ ] Create route group `/api/v1` for versioned endpoints
  - [ ] Register health check endpoint at `/health` (outside versioned group)
  - [ ] Document route registration pattern for future endpoints

- [ ] **Task 8: Implement graceful shutdown** (AC: 12)
  - [ ] Setup signal handling for SIGTERM and SIGINT in `main.go`
  - [ ] On shutdown signal: stop accepting new connections, drain in-flight requests
  - [ ] Close database pool: `db.Close()`
  - [ ] Close Redis client connection
  - [ ] Close Meilisearch client connection
  - [ ] Log shutdown events at INFO level
  - [ ] Exit with appropriate status code

- [ ] **Task 9: Write unit tests for health check endpoint** (AC: 11)
  - [ ] Create `/backend/internal/api/handlers/health_test.go`
  - [ ] Test case: All services healthy returns 200 with correct JSON structure
  - [ ] Test case: Database unavailable returns 503 with error in services.database
  - [ ] Test case: Redis unavailable returns 503 with error in services.redis
  - [ ] Test case: Meilisearch unavailable returns 503 with error in services.meilisearch
  - [ ] Use mocked service clients for isolated testing

- [ ] **Task 10: Verify server startup and manual testing**
  - [ ] **Verify Docker services are running:**
    - [ ] Run `docker-compose ps` - confirm postgres, redis, meilisearch show "Up" status
    - [ ] Check service logs: `docker-compose logs postgres | tail -n 20`
    - [ ] Check service logs: `docker-compose logs redis | tail -n 20`
    - [ ] Check service logs: `docker-compose logs meilisearch | tail -n 20`
  - [ ] **Configure and start backend server:**
    - [ ] Create `.env` file with all required configuration variables
    - [ ] Run `go run cmd/server/main.go` and verify startup logs show all services connected
    - [ ] Confirm log output includes: port, environment, log_level, api_version
  - [ ] **Test health check endpoint:**
    - [ ] Execute: `curl http://localhost:8080/health`
    - [ ] Verify JSON response contains: `{"status": "healthy", "services": {"database": "ok", "redis": "ok", "meilisearch": "ok"}}`
    - [ ] Verify HTTP status code is 200
  - [ ] **Test graceful shutdown:**
    - [ ] Send SIGTERM (Ctrl+C) to running server
    - [ ] Verify shutdown logs show: "shutting down server...", database closed, redis closed, "server stopped gracefully"

## Dev Notes

### Previous Story Insights

From Story 1.2 (Database Schema Design):
- PostgreSQL service is already running via Docker Compose on port 5432
- DATABASE_URL should be configured in `.env` file
- Database schema is fully migrated with all core tables (users, tenants, mailboxes, emails, attachments, jobs, audit_logs, settings)
- pgx driver should be used for all database operations

[Reference: Story 1.2 completion context]

From Story 1.1 (Project Scaffolding):
- Monorepo structure is established with `/backend`, `/frontend`, `/docker`, `/docs`, `/migrations` folders
- Backend folder structure includes `/cmd/server`, `/internal`, `/pkg` directories
- Docker Compose file includes PostgreSQL 16, Redis 7, Meilisearch 1.6 service definitions
- All services should be accessible from the backend application

[Reference: Story 1.1 completion context]

### Tech Stack Requirements

**Backend Framework:**
- **Technology:** Fiber v3
- **Purpose:** Express-like web framework for Go
- **Rationale:** Built on fasthttp (fastest Go HTTP), minimal overhead, middleware ecosystem, familiar API
- **Version:** v3 (latest stable)

[Source: architecture/tech-stack.md - Backend Framework row]

**Database Driver:**
- **Technology:** pgx/v5 with pgxpool.Pool for connection pooling
- **Purpose:** High-performance PostgreSQL driver
- **Connection String Format:** `postgres://username:password@host:port/database?sslmode=disable`
- **Environment Variable:** `DATABASE_URL`

[Source: architecture/tech-stack.md - Database row]
[Source: architecture/backend-architecture.md#database-access-layer]

**Cache:**
- **Technology:** Redis 7+
- **Client Library:** go-redis/redis/v9
- **Purpose:** High-performance in-memory caching
- **Connection String Format:** `redis://host:port` or `redis://:password@host:port`

[Source: architecture/tech-stack.md - Cache row]

**Search Engine:**
- **Technology:** Meilisearch 1.6+
- **Client Library:** meilisearch-go SDK
- **Purpose:** Full-text search with typo tolerance
- **Connection String Format:** `http://host:port`

[Source: architecture/tech-stack.md - Search Engine row]

**Logging:**
- **Technology:** Zap (Structured JSON Logging)
- **Purpose:** Machine-parseable structured logging
- **Format:** JSON to stdout
- **Log Levels:** DEBUG, INFO, WARN, ERROR

[Source: architecture/tech-stack.md - Logging row]

### Backend Project Structure

**Application Entrypoint:**
```
/backend/cmd/server/main.go              # Application entrypoint
```

**Configuration:**
```
/backend/internal/config/config.go       # Configuration management
```

**Database Layer:**
```
/backend/internal/database/postgres.go   # Connection setup
```

**Cache Layer:**
```
/backend/internal/cache/redis.go         # Redis client setup
```

**Search Layer:**
```
/backend/internal/search/meilisearch.go  # Meilisearch client setup
```

**API Layer:**
```
/backend/internal/api/
   middleware/                          # Middleware
      cors.go
      logging.go
      error_handler.go
   handlers/                            # Route handlers
      health.go
   routes.go                            # Route registration
```

**Utilities:**
```
/backend/internal/utils/
   logger.go                            # Logger setup
```

[Source: architecture/backend-architecture.md#service-architecture]
[Source: architecture/project-structure.md]

### Configuration Management

**Configuration Loading Pattern:**

```go
// internal/config/config.go
package config

import (
    "fmt"
    "os"
    "github.com/joho/godotenv"
)

type Config struct {
    DatabaseURL        string
    RedisURL           string
    MeilisearchURL     string
    MeilisearchAPIKey  string
    JWTSecret          string
    ServerPort         string
    LogLevel           string
}

func LoadConfig() (*Config, error) {
    // Load .env file (optional for production)
    _ = godotenv.Load()

    cfg := &Config{
        DatabaseURL:       os.Getenv("DATABASE_URL"),
        RedisURL:          os.Getenv("REDIS_URL"),
        MeilisearchURL:    os.Getenv("MEILISEARCH_URL"),
        MeilisearchAPIKey: os.Getenv("MEILISEARCH_API_KEY"), // Optional: empty string if not set
        JWTSecret:         os.Getenv("JWT_SECRET"),
        ServerPort:        getEnvOrDefault("SERVER_PORT", "8080"),
        LogLevel:          getEnvOrDefault("LOG_LEVEL", "INFO"),
    }

    // Validate required fields
    if cfg.DatabaseURL == "" {
        return nil, fmt.Errorf("DATABASE_URL is required")
    }
    if cfg.RedisURL == "" {
        return nil, fmt.Errorf("REDIS_URL is required")
    }
    if cfg.MeilisearchURL == "" {
        return nil, fmt.Errorf("MEILISEARCH_URL is required")
    }
    if cfg.JWTSecret == "" {
        return nil, fmt.Errorf("JWT_SECRET is required")
    }

    return cfg, nil
}

func getEnvOrDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
```

**Environment Variables Required:**
- `DATABASE_URL` - PostgreSQL connection string
- `REDIS_URL` - Redis connection string
- `MEILISEARCH_URL` - Meilisearch server URL
- `MEILISEARCH_API_KEY` - Meilisearch API key (optional, leave empty if no auth)
- `JWT_SECRET` - Secret for JWT token signing (will be used in Story 1.4)
- `SERVER_PORT` - HTTP server port (default: 8080)
- `LOG_LEVEL` - Log level: DEBUG, INFO, WARN, ERROR (default: INFO)

**CRITICAL RULE:** Never access `os.Getenv()` directly in business logic. Always use the config object.

[Source: architecture/coding-standards.md#environment-variables]

### Database Connection Setup

**Connection Pool Pattern:**

```go
// internal/database/postgres.go
package database

import (
    "context"
    "fmt"
    "github.com/jackc/pgx/v5/pgxpool"
)

func NewPostgresPool(ctx context.Context, databaseURL string) (*pgxpool.Pool, error) {
    config, err := pgxpool.ParseConfig(databaseURL)
    if err != nil {
        return nil, fmt.Errorf("unable to parse database URL: %w", err)
    }

    // Configure connection pool
    config.MinConns = 2
    config.MaxConns = 10

    pool, err := pgxpool.NewWithConfig(ctx, config)
    if err != nil {
        return nil, fmt.Errorf("unable to create connection pool: %w", err)
    }

    // Validate connection
    if err := pool.Ping(ctx); err != nil {
        return nil, fmt.Errorf("unable to connect to database: %w", err)
    }

    return pool, nil
}
```

**Connection Pool Settings:**
- MinConns: 2 (minimum idle connections)
- MaxConns: 10 (maximum concurrent connections)

**Health Check:** Use `pool.Ping(ctx)` to verify connectivity

[Source: architecture/backend-architecture.md#database-access-layer]

### Redis Client Setup

**Redis Connection Pattern:**

```go
// internal/cache/redis.go
package cache

import (
    "context"
    "fmt"
    "github.com/redis/go-redis/v9"
)

func NewRedisClient(redisURL string) (*redis.Client, error) {
    opts, err := redis.ParseURL(redisURL)
    if err != nil {
        return nil, fmt.Errorf("unable to parse Redis URL: %w", err)
    }

    client := redis.NewClient(opts)

    // Validate connection
    ctx := context.Background()
    if err := client.Ping(ctx).Err(); err != nil {
        return nil, fmt.Errorf("unable to connect to Redis: %w", err)
    }

    return client, nil
}
```

**Health Check:** Use `client.Ping(ctx).Err()` to verify connectivity

[Source: architecture/tech-stack.md - Cache row]

### Meilisearch Client Setup

**Meilisearch Connection Pattern:**

```go
// internal/search/meilisearch.go
package search

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func NewMeilisearchClient(meilisearchURL string, apiKey string) (*meilisearch.Client, error) {
    client := meilisearch.NewClient(meilisearch.ClientConfig{
        Host:   meilisearchURL,
        APIKey: apiKey, // Optional: pass empty string if no authentication
    })

    // Validate connection by checking health
    health, err := client.Health()
    if err != nil {
        return nil, fmt.Errorf("unable to connect to Meilisearch: %w", err)
    }

    if health.Status != "available" {
        return nil, fmt.Errorf("Meilisearch is not available: status=%s", health.Status)
    }

    return client, nil
}
```

**Health Check:** Use `client.Health()` to verify connectivity and availability

[Source: architecture/tech-stack.md - Search Engine row]

### Structured Logging Setup

**Logger Initialization Pattern:**

```go
// internal/utils/logger.go
package utils

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
)

func NewLogger(logLevel string) (*zap.Logger, error) {
    level := zapcore.InfoLevel
    switch logLevel {
    case "DEBUG":
        level = zapcore.DebugLevel
    case "INFO":
        level = zapcore.InfoLevel
    case "WARN":
        level = zapcore.WarnLevel
    case "ERROR":
        level = zapcore.ErrorLevel
    }

    config := zap.Config{
        Level:            zap.NewAtomicLevelAt(level),
        Encoding:         "json",
        OutputPaths:      []string{"stdout"},
        ErrorOutputPaths: []string{"stderr"},
        EncoderConfig: zapcore.EncoderConfig{
            TimeKey:        "timestamp",
            LevelKey:       "level",
            NameKey:        "logger",
            CallerKey:      "caller",
            MessageKey:     "message",
            StacktraceKey:  "stacktrace",
            LineEnding:     zapcore.DefaultLineEnding,
            EncodeLevel:    zapcore.LowercaseLevelEncoder,
            EncodeTime:     zapcore.ISO8601TimeEncoder,
            EncodeDuration: zapcore.SecondsDurationEncoder,
            EncodeCaller:   zapcore.ShortCallerEncoder,
        },
    }

    return config.Build()
}
```

**Log Format:** JSON with fields: timestamp, level, logger, message, caller

**Log Levels:** DEBUG, INFO, WARN, ERROR

[Source: architecture/tech-stack.md - Logging row]

### Fiber Middleware Configuration

**Middleware Order:**

1. **Request ID Middleware** - Generate unique ID for each request
2. **Logging Middleware** - Log request start/end with duration
3. **CORS Middleware** - Handle cross-origin requests
4. **Recover Middleware** - Catch panics and return 500 errors
5. **Error Handler Middleware** - Format errors consistently

**Middleware Application Pattern:**

```go
// cmd/server/main.go
import (
    "github.com/gofiber/fiber/v3"
    "github.com/gofiber/fiber/v3/middleware/requestid"
    "github.com/gofiber/fiber/v3/middleware/recover"
    "ironarchive/internal/api/middleware"
)

app := fiber.New(fiber.Config{
    ErrorHandler: middleware.ErrorHandler,
})

// Apply middleware in order
app.Use(requestid.New())
app.Use(middleware.Logger(logger))
app.Use(middleware.CORS())
app.Use(recover.New())
```

[Source: architecture/backend-architecture.md#authentication-and-authorization-middleware]

**CORS Middleware:**

```go
// internal/api/middleware/cors.go
package middleware

import (
    "github.com/gofiber/fiber/v3"
    "github.com/gofiber/fiber/v3/middleware/cors"
)

func CORS() fiber.Handler {
    return cors.New(cors.Config{
        AllowOrigins:     "*", // Configure based on environment
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
        AllowHeaders:     []string{"Origin", "Content-Type", "Authorization"},
        AllowCredentials: false,
    })
}
```

**Logging Middleware:**

```go
// internal/api/middleware/logging.go
package middleware

import (
    "time"
    "github.com/gofiber/fiber/v3"
    "go.uber.org/zap"
)

func Logger(logger *zap.Logger) fiber.Handler {
    return func(c *fiber.Ctx) error {
        start := time.Now()

        err := c.Next()

        duration := time.Since(start)
        logger.Info("request completed",
            zap.String("method", c.Method()),
            zap.String("path", c.Path()),
            zap.Int("status", c.Response().StatusCode()),
            zap.Duration("duration", duration),
            zap.String("request_id", c.Get("X-Request-ID")),
        )

        return err
    }
}
```

[Source: architecture/backend-architecture.md#authentication-and-authorization-middleware]

### Error Handling Pattern

**Error Handler Middleware:**

```go
// internal/api/middleware/error_handler.go
package middleware

import (
    "github.com/gofiber/fiber/v3"
)

func ErrorHandler(c *fiber.Ctx, err error) error {
    code := fiber.StatusInternalServerError
    message := "Internal Server Error"

    if e, ok := err.(*fiber.Error); ok {
        code = e.Code
        message = e.Message
    }

    return c.Status(code).JSON(fiber.Map{
        "error": fiber.Map{
            "code":    code,
            "message": message,
        },
    })
}
```

**Consistent Error Response Format:**
```json
{
  "error": {
    "code": 500,
    "message": "Error description"
  }
}
```

**CRITICAL RULE:** All API routes must use the standard error handler. Return errors using `fiber.NewError(statusCode, message)`.

[Source: architecture/coding-standards.md#error-handling-strategy]

### Health Check Endpoint Specification

**Endpoint:** `GET /health`

**Success Response (200 OK):**
```json
{
  "status": "healthy",
  "services": {
    "database": "ok",
    "redis": "ok",
    "meilisearch": "ok"
  }
}
```

**Failure Response (503 Service Unavailable):**
```json
{
  "status": "unhealthy",
  "services": {
    "database": "ok",
    "redis": "connection refused",
    "meilisearch": "ok"
  }
}
```

**Health Check Logic:**
- Check database: `db.Ping(ctx)`
- Check Redis: `redis.Ping(ctx).Err()`
- Check Meilisearch: `client.Health()`
- Return 200 only if ALL services are healthy
- Return 503 if ANY service is unhealthy
- Include specific error messages in the response

No specific health check guidance found in architecture docs - implementing standard pattern

### API Versioning Structure

**Route Group Pattern:**

```go
// internal/api/routes.go
package api

import (
    "github.com/gofiber/fiber/v3"
    "ironarchive/internal/api/handlers"
)

func SetupRoutes(app *fiber.App, healthHandler *handlers.HealthHandler) {
    // Health check endpoint (no versioning)
    app.Get("/health", healthHandler.Handle)

    // API v1 route group
    v1 := app.Group("/api/v1")

    // Future endpoints will be registered under v1 group
    // Example: v1.Get("/tenants", tenantHandler.List)
}
```

**API Version Path:** `/api/v1/...`

**Non-versioned Endpoints:** `/health` (infrastructure endpoints)

[Source: architecture/backend-architecture.md#service-architecture]

### Graceful Shutdown Pattern

**Startup Logging:**

When the server starts successfully, log comprehensive startup information:

```go
logger.Info("server started successfully",
    zap.String("port", cfg.ServerPort),
    zap.String("environment", "development"),
    zap.String("log_level", cfg.LogLevel),
    zap.String("api_version", "v1"),
)
```

**Signal Handling and Shutdown:**

```go
// cmd/server/main.go
import (
    "os/signal"
    "syscall"
)

func main() {
    // ... setup code ...

    // Setup signal handling
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    // Start server in goroutine
    go func() {
        if err := app.Listen(":" + cfg.ServerPort); err != nil {
            logger.Fatal("server failed to start", zap.Error(err))
        }
    }()

    logger.Info("server started successfully",
        zap.String("port", cfg.ServerPort),
        zap.String("environment", "development"),
        zap.String("log_level", cfg.LogLevel),
        zap.String("api_version", "v1"),
    )

    // Wait for shutdown signal
    <-quit
    logger.Info("shutting down server...")

    // Shutdown server (drain in-flight requests)
    if err := app.Shutdown(); err != nil {
        logger.Error("server shutdown error", zap.Error(err))
    }

    // Close database connection
    db.Close()
    logger.Info("database connection closed")

    // Close Redis connection
    if err := redisClient.Close(); err != nil {
        logger.Error("redis close error", zap.Error(err))
    }
    logger.Info("redis connection closed")

    // Meilisearch client doesn't need explicit close

    logger.Info("server stopped gracefully")
}
```

**Shutdown Steps:**
1. Stop accepting new connections
2. Drain in-flight requests
3. Close database pool
4. Close Redis client
5. Log all shutdown events
6. Exit with status 0

[Source: Common Go graceful shutdown pattern]

### Example `.env` File

```env
# Database
DATABASE_URL=postgres://ironarchive:password@localhost:5432/ironarchive?sslmode=disable

# Redis
REDIS_URL=redis://localhost:6379

# Meilisearch
MEILISEARCH_URL=http://localhost:7700
MEILISEARCH_API_KEY=  # Optional: leave empty if Meilisearch has no authentication

# JWT (will be used in Story 1.4)
JWT_SECRET=your-secret-key-min-32-characters-long

# Server
SERVER_PORT=8080
LOG_LEVEL=INFO
```

**IMPORTANT:** Never commit `.env` file to version control. Use `.env.example` as template.

[Source: architecture/coding-standards.md#environment-variables]

### Project Structure Alignment

**File Locations for This Story:**

```
/backend/
   cmd/server/main.go                      # NEW: Application entrypoint
   internal/
      config/config.go                    # NEW: Configuration management
      database/postgres.go                # NEW: Database connection setup
      cache/redis.go                      # NEW: Redis client setup
      search/meilisearch.go               # NEW: Meilisearch client setup
      api/
         middleware/
            cors.go                     # NEW: CORS middleware
            logging.go                  # NEW: Logging middleware
            error_handler.go            # NEW: Error handler
         handlers/
            health.go                   # NEW: Health check handler
            health_test.go              # NEW: Health check tests
         routes.go                       # NEW: Route registration
      utils/
          logger.go                       # NEW: Logger setup
   go.mod                                  # UPDATED: Add new dependencies
   go.sum                                  # UPDATED: Dependency checksums
   Makefile                                # UPDATED: Add run/test targets
```

**No conflicts found** between epic requirements and project structure.

[Source: architecture/project-structure.md]

### Go Dependencies to Add

```bash
go get github.com/gofiber/fiber/v3
go get github.com/jackc/pgx/v5/pgxpool
go get github.com/redis/go-redis/v9
go get github.com/meilisearch/meilisearch-go
go get go.uber.org/zap
go get github.com/joho/godotenv
go get github.com/stretchr/testify  # For testing
```

[Source: architecture/tech-stack.md]

## Testing

### Testing Standards for This Story

**Backend Testing Framework:**
- Go Testing (standard library)
- Testify 1.9+ for assertions and test helpers

[Source: architecture/testing-strategy.md - Backend Testing row]

**Test Organization:**

For this story, focus on **unit tests for the health check endpoint**:

**Test File Location:**
```
/backend/internal/api/handlers/
   health.go
   health_test.go           # Unit tests for health endpoint
```

[Source: architecture/testing-strategy.md#test-organization]

**Test Coverage Requirements:**

1. **Health Check Handler Tests:**
   - All services healthy � returns 200 with correct JSON
   - Database unhealthy � returns 503 with error in services.database
   - Redis unhealthy � returns 503 with error in services.redis
   - Meilisearch unhealthy � returns 503 with error in services.meilisearch
   - Multiple services unhealthy � returns 503 with all errors

2. **Test Pattern:**
   - Use mocked database, Redis, and Meilisearch clients
   - Use httptest for testing HTTP handlers
   - Use Testify for assertions

**Test Mocking Interfaces:**

For testability, the HealthHandler should accept interfaces rather than concrete types. This allows for easy mocking in unit tests.

```go
// internal/api/handlers/health.go
package handlers

import (
    "context"
    "github.com/gofiber/fiber/v3"
    "github.com/meilisearch/meilisearch-go"
    "github.com/redis/go-redis/v9"
)

// Define minimal interfaces for dependencies
type DatabaseHealthChecker interface {
    Ping(ctx context.Context) error
}

type RedisHealthChecker interface {
    Ping(ctx context.Context) *redis.StatusCmd
}

type MeilisearchHealthChecker interface {
    Health() (*meilisearch.Health, error)
}

// HealthHandler accepts interfaces for testability
type HealthHandler struct {
    db          DatabaseHealthChecker
    redis       RedisHealthChecker
    meilisearch MeilisearchHealthChecker
}

func NewHealthHandler(db DatabaseHealthChecker, redis RedisHealthChecker, meilisearch MeilisearchHealthChecker) *HealthHandler {
    return &HealthHandler{
        db:          db,
        redis:       redis,
        meilisearch: meilisearch,
    }
}

func (h *HealthHandler) Handle(c *fiber.Ctx) error {
    // Implementation here
}
```

**Mock Implementations for Testing:**

```go
// internal/api/handlers/health_test.go - Mock implementations
type MockDatabase struct {
    healthy bool
    err     error
}

func (m *MockDatabase) Ping(ctx context.Context) error {
    if !m.healthy {
        return m.err
    }
    return nil
}

type MockRedis struct {
    healthy bool
    err     error
}

func (m *MockRedis) Ping(ctx context.Context) *redis.StatusCmd {
    cmd := redis.NewStatusCmd(ctx)
    if !m.healthy {
        cmd.SetErr(m.err)
    }
    return cmd
}

type MockMeilisearch struct {
    healthy bool
    err     error
}

func (m *MockMeilisearch) Health() (*meilisearch.Health, error) {
    if !m.healthy {
        return nil, m.err
    }
    return &meilisearch.Health{Status: "available"}, nil
}
```

**Example Test Structure:**

```go
// backend/internal/api/handlers/health_test.go
package handlers_test

import (
    "testing"
    "net/http/httptest"
    "github.com/gofiber/fiber/v3"
    "github.com/stretchr/testify/assert"
    "ironarchive/internal/api/handlers"
)

func TestHealthHandler_AllServicesHealthy(t *testing.T) {
    app := fiber.New()

    // Create mocked clients
    mockDB := &MockDatabase{healthy: true}
    mockRedis := &MockRedis{healthy: true}
    mockMeilisearch := &MockMeilisearch{healthy: true}

    handler := handlers.NewHealthHandler(mockDB, mockRedis, mockMeilisearch)
    app.Get("/health", handler.Handle)

    req := httptest.NewRequest("GET", "/health", nil)
    resp, err := app.Test(req)

    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode)

    // Parse response body and verify structure
    var body map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&body)
    assert.Equal(t, "healthy", body["status"])
    assert.Equal(t, "ok", body["services"].(map[string]interface{})["database"])
}

func TestHealthHandler_DatabaseUnhealthy(t *testing.T) {
    app := fiber.New()

    mockDB := &MockDatabase{healthy: false, err: "connection refused"}
    mockRedis := &MockRedis{healthy: true}
    mockMeilisearch := &MockMeilisearch{healthy: true}

    handler := handlers.NewHealthHandler(mockDB, mockRedis, mockMeilisearch)
    app.Get("/health", handler.Handle)

    req := httptest.NewRequest("GET", "/health", nil)
    resp, err := app.Test(req)

    assert.NoError(t, err)
    assert.Equal(t, 503, resp.StatusCode)

    var body map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&body)
    assert.Equal(t, "unhealthy", body["status"])
    assert.Contains(t, body["services"].(map[string]interface{})["database"], "connection refused")
}
```

[Source: architecture/testing-strategy.md#backend-api-test]

**Running Tests:**

```bash
# Run all tests
cd backend
go test ./...

# Run tests with coverage
go test -cover ./...

# Run tests for specific package
go test ./internal/api/handlers/...
```

**Manual Verification Steps:**

1. Start Docker services: `docker-compose up -d`
2. Verify all services are running: `docker-compose ps`
3. Create `.env` file with all required variables (see Example .env File section)
4. Run server: `go run cmd/server/main.go`
5. Verify startup logs show successful connection to all services
6. Test health endpoint: `curl http://localhost:8080/health`
7. Verify response: `{"status": "healthy", "services": {"database": "ok", "redis": "ok", "meilisearch": "ok"}}`
8. Stop one service (e.g., `docker-compose stop redis`) and verify health endpoint returns 503
9. Restart service: `docker-compose start redis`
10. Test graceful shutdown: `Ctrl+C` and verify clean shutdown logs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | Initial story creation for Epic 1 Story 3 | Bob (Scrum Master) |
| 2025-10-17 | 1.1 | Quality improvements: Fixed Fiber v3 middleware API patterns (CORS, RequestID, Recover), added Meilisearch API key support, added test mocking interface guidance, restructured Task 5 for clarity, enhanced startup logging and Docker verification steps | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent during implementation_

### Debug Log References

_To be populated by Dev Agent during implementation_

### Completion Notes List

_To be populated by Dev Agent during implementation_

### File List

_To be populated by Dev Agent during implementation_

## QA Results

_To be populated by QA Agent after story completion_
